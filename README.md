# HuaweiChallenge-22nd

[华为算法精英实战营第二十二期-高性能动态内存管理算法](https://competition.huaweicloud.com/information/1000042168/introduction)

# 赛题核心点介绍

1. Setroot 的次数不会很多
2. 在记分时分母为 user\_print\_deadtime_i-actual\_deadtime_i+10 因为有加 $10$，所以当两个非常接近时其实获得的贡献并不大，而在整体算力受限的情况下尽量平均各个点的被删时间间隔更好。

# 整体思路介绍

1. 每个点记录出边和入边（反向图），通过 vector 维护有序序列，加入新的边时 upper_bound 到对应位置插入，删除时 lower_bound 找到对应位置删除。考虑到数据中每个点的边并不会很多，在 vector 底层的访存优化下这样维护图速度并不慢。而且在最需要优化的遍历操作时这样能让访问更加连续。

2. 当每次删除一条边 $u\rightarrow v$ 时，$v$ 点可能会被删除，所以在反向图中进行遍历，如果遍历到 root 节点，那么 v 没有被删除；如果遍历到的点大于某阈值（程序中为 $50$）则也不删除，否则当遍历出的连通块找到后，整个连通块都要被删除。

3. 在删点和删边时都需要进行 2 操作。

4. 在 Setroot 时对被修改的 root 节点进行类似操作，但是阈值更大，同时需要记录每个点的入度个数，如果一个点从 root 变成了非 root，且入度为 $0$，那么也需要删除。

5. 在 Ask 操作时，记录一个使用算力值（通过每次正向 BFS 预计要花费多少算力简单统计，实际中使用运行时间查询函数可能会更好）当算力满足当前预计花费算力时，进行一次正向的 BFS，彻底删除图中需要删除的点。

# 核心策略详解

在测试过程中，只在有边被删除时在反向图中 BFS，就能获得很高的分（大于 $3.7\times 10^7$）而这部分是极难优化的，调节阈值在不 TLE 范围内对结果都没有产生显著影响。

所以最后能优化的就是正向 BFS 的时机，对于算力的分配。

```C++
inline double F1(const double x)
{
	return pow(x,DB);
}
inline double F2(const double x)
{
	return pow(x,1/DB);
}
inline double F3(const double x)
{
	if(x<CUT)
	{
		return CUT*F1(x/CUT);
	}
	else
	{
		return CUT+(1-CUT)*F2((x-CUT)/(1-CUT));
	}
}
```
设置了如上函数来分配总算力，让算力在数据的中间时分配的最多，因为考虑到开始时更多的是加边，而结束时剩余的点数量较少。

对于 Setroot 后，分配更多的算力进行正向 BFS 操作，因为 Setroot 对于整个图的影响非常大。

在相邻两次正向 BFS 之间加上对两次操作中删除的点的数量，边的数量，加点的数量等进行限制，如果修改过少认为这次查询意义是不大的。
